package libs.PathFinder {	import flash.utils.Dictionary;	import flash.geom.Point;		public class PathFinder {		private var finX;		private var finY;		private var level:Array;		private var openList:Dictionary;		private var closedList:Dictionary;		public var path:Array;				public static function go(xIni, yIni, xFin, yFin, lvlData):Array {			var finder:PathFinder = new PathFinder(xIni, yIni, xFin, yFin, lvlData);			return finder.path;		}				public function PathFinder(xIni, yIni, xFin, yFin, lvlData) {			finX = xFin;			finY = yFin;			level = lvlData;			openList = new Dictionary(true);			closedList = new Dictionary(true);			path = new Array();						var node:PathNode = new PathNode(xIni, yIni, 0, 0, null);			openList[xIni + " " + yIni] = node;						this.SearchLevel();		}				private function SearchLevel():void {			var curNode:PathNode;			var lowF = 100000;			var finished:Boolean = false;						for each (var node in openList) {				var curF = node.g + node.h;								if (lowF > curF) {					lowF = curF;					curNode = node;				}			}						if (curNode == null) {return;}						delete openList[curNode.x + " " + curNode.y];			closedList[curNode.x + " " + curNode.y] = curNode;					if (curNode.x == finX && curNode.y == finY) {				var endNode:PathNode = curNode;				finished = true;			}						for (var i = -1; i < 2; i++) {				for (var j = -1; j < 2; j++) {					var col = curNode.x + i;					var row = curNode.y + j;										if ((col >= 0 && col < level[0].length) && (row >= 0 && row < level.length) && (i != 0 || j != 0)) {												if (level[row][col] == 0 && closedList[col + " " + row] == null && openList[col + " " + row] == null) {													var g = 10;							if (i != 0 && j != 0) {								g = 14;							}														var h = (Math.abs(col - finX)) + (Math.abs(row - finY)) * 10;														var found:PathNode = new PathNode(col, row, g, h, curNode);							openList[col + " " + row] = found;						}					}				}			}						if (finished == false) {				this.SearchLevel();			} else {				this.RetracePath(endNode);			}	}			private function RetracePath(node):void {			var step:Point = new Point(node.x, node.y);			path.push(step);						if (node.g > 0) {				this.RetracePath(node.parentNode);			}		}			}}