package code {	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.geom.Point;		import flash.desktop.NativeApplication; 	import flash.display.Loader; 	import flash.display.MovieClip; 	import flash.display.StageAlign; 	import flash.display.StageScaleMode; 	import flash.events.ErrorEvent; 	import flash.events.Event; 	import flash.events.IOErrorEvent; 	import flash.events.MediaEvent; 	import flash.media.CameraUI; 	import flash.media.MediaPromise; 	import flash.media.MediaType;     		import libs.PathFinder.*;		public class Demo extends MovieClip {		private const gridSize = 30;		private const gridHalf = gridSize / 2;		private const gridXOffset = 0;		private const gridYOffset = 0;		private const numCols = 9;		private const numRows = 11;				private var dragX;		private var dragY;				private var startTile:MovieClip;		private var endTile:MovieClip;		private var end2:MovieClip;		private var crds:MovieClip;		private var camm:MovieClip;				private var level:Array;		private var walls:Array;		private var hitboxes:Array;				private var moves:Array;		private var moveSpots:Array;								private var deviceCameraApp:CameraUI = new CameraUI();        private var imageLoader:Loader; 		              public function CameraUIStillImage() {               this.stage.align = StageAlign.TOP_LEFT;               this.stage.scaleMode = StageScaleMode.NO_SCALE;                      if( CameraUI.isSupported )               {                trace( "Initializing camera..." );                    deviceCameraApp.addEventListener( MediaEvent.COMPLETE, imageCaptured );                deviceCameraApp.addEventListener( Event.CANCEL, captureCanceled );                deviceCameraApp.addEventListener( ErrorEvent.ERROR, cameraError );                deviceCameraApp.launch( MediaType.IMAGE );               }               else               {                trace( "Camera interface is not supported.");               }          }              private function imageCaptured( event:MediaEvent ):void          {               trace( "Media captured..." );                      var imagePromise:MediaPromise = event.data;                      if( imagePromise.isAsync )               {                trace( "Asynchronous media promise." );                imageLoader = new Loader();                imageLoader.contentLoaderInfo.addEventListener( Event.COMPLETE, asyncImageLoaded );                imageLoader.addEventListener( IOErrorEvent.IO_ERROR, cameraError );                                imageLoader.loadFilePromise( imagePromise );               }               else               {                trace( "Synchronous media promise." );                imageLoader.loadFilePromise( imagePromise );                showMedia( imageLoader );               }          }              private function captureCanceled( event:Event ):void          {               trace( "Media capture canceled." );               NativeApplication.nativeApplication.exit();          }              private function asyncImageLoaded( event:Event ):void          {               trace( "Media loaded in memory." );               showMedia( imageLoader );              }              private function showMedia( loader:Loader ):void          {               this.addChild( loader );          }                private function cameraError( error:ErrorEvent ):void          {               trace( "Error:" + error.text );               NativeApplication.nativeApplication.exit();          }														public function Demo() {			this.gotoAndStop(1);			this.LoadLevel();			//this.CameraUIStillImage();		}				private function LoadLevel():void {			var coords:Array;			trace("am i here");						level = [				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 1, 1, 1, 1, 1, 1, 1, 1, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];						this.PlaceWalls();			this.PlaceHitboxes();						startTile = new Start();			coords = this.Grid2Pixel(2, 1);			startTile.x = coords[0];			startTile.y = coords[1];			this.addChild(startTile);			startTile.buttonMode = true;			startTile.mouseChildren = false;			startTile.addEventListener(MouseEvent.MOUSE_DOWN, DragObject);						endTile = new End();			coords = this.Grid2Pixel(4, 8);			endTile.x = coords[0];			endTile.y = coords[1];			this.addChild(endTile);			endTile.buttonMode = true;			endTile.mouseChildren = false;			endTile.addEventListener(MouseEvent.MOUSE_DOWN, DragObject);						end2 = new End2();			end2.x = 0;			end2.y = 360;			this.addChild(end2);			end2.buttonMode = true;			end2.mouseChildren = false;			end2.addEventListener(MouseEvent.MOUSE_DOWN, showCredits);						camm = new Camm();			camm.x = 20;			camm.y = 440;			this.addChild(camm);			camm.buttonMode = true;			camm.mouseChildren = false;			camm.addEventListener(MouseEvent.MOUSE_DOWN, launchCamera);									movespots = new Array();			this.FindPath();		}				private function launchCamera(e:MouseEvent):void{						CameraUIStillImage();					}				private function showCredits(e:MouseEvent):void{			//trace("dsfsdf");			crds = new credits();			crds.x=0;			crds.y=0;			crds.buttonMode = true;			this.addChild(crds);			crds.addEventListener(MouseEvent.CLICK, closeCredits);					}				private function closeCredits(e:MouseEvent):void{			crds.removeEventListener(MouseEvent.CLICK, closeCredits);			this.removeChild(crds);					}				private function PlaceWalls():void {			walls = new Array();						//place on all ones in level array						for (var i = 0; i <= numRows; i++) {				for (var j = 0; j <= numCols; j++) {					if (level[i][j] == 1) {						var wall:MovieClip = new Wall();						var coords:Array = this.Grid2Pixel(j, i);						wall.x = coords[0];						wall.y = coords[1];						this.addChild(wall);						walls.push(wall);					}				}			}		}			private function PlaceHitboxes():void {			hitboxes = new Array();						for (var i = 0; i <= numRows; i++) {				for (var j = 0; j <= numCols; j++) {					if (level[i][j] == 0) {						var hitbox:MovieClip = new HitBox();						var coords:Array = this.Grid2Pixel(j, i);						hitbox.x = coords[0];						hitbox.y = coords[1];						hitboxes.push(hitbox);					}				}			}		}				private function FindPath():void {			var coords1:Array = this.Pixel2Grid(startTile.x, startTile.y);			var coords2:Array = this.Pixel2Grid(endTile.x, endTile.y);			trace("S >"+startTile.x+"/"+startTile.y);			trace("E >"+endTile.x+"/"+endTile.y);			moves = PathFinder.go(coords1[0], coords1[1], coords2[0], coords2[1], level);			this.PlaceMoves();		}				private function PlaceMoves():void {			var i = 0;			for each (var move in moves) {				i++;				var spot:MovieClip = new MoveSpot();				var coords:Array = this.Grid2Pixel(move.x, move.y);				spot.x = coords[0];				spot.y = coords[1];								this.addChildAt(spot,1);				movespots.push(spot);			}		}				private function DragObject(e:MouseEvent):void {			trace("draggin from "+dragX+"/"+dragY);			e.target.startDrag();			e.target.addEventListener(MouseEvent.MOUSE_UP, DropObject);						dragX = e.target.x;			dragY = e.target.y;						for each (var spot in movespots) {				this.removeChild(spot);			}			movespots.length = 0;		}		private function DropObject(e:MouseEvent):void {			trace("droppin at "+e.target.x+"/"+e.target.y);			e.target.stopDrag();			e.target.removeEventListener(MouseEvent.MOUSE_UP, DropObject);						if((e.target.x > 30 && e.target.x < 270 && e.target.y > 180 && e.target.y < 210) || e.target.y > 360){				e.target.x = dragX;				e.target.y = dragY;			}						this.FindPath();		}				public function Pixel2Grid(xPos, yPos):Array {			var coords:Array = new Array();			var col;			var row;			trace("P2G: "+xPos+"/"+yPos);						if(xPos < 30){				col = 0;			}else if(xPos < 60){				col = 1;			}else if(xPos < 90){				col = 2;			}else if(xPos < 120){				col = 3;			}else if(xPos < 150){				col = 4;			}else if(xPos < 180){				col = 5;			}else if(xPos < 210){				col = 6;			}else if(xPos < 240){				col = 7;			}else if(xPos < 270){				col = 8;			}else if(xPos < 300){				col = 9;			}						if(yPos < 30){				row = 0;			}else if(yPos < 60){				row = 1;			}else if(yPos < 90){				row = 2;			}else if(yPos < 120){				row = 3;			}else if(yPos < 150){				row = 4;			}else if(yPos < 180){				row = 5;			}else if(yPos < 210){				row = 6;			}else if(yPos < 240){				row = 7;			}else if(yPos < 270){				row = 8;			}else if(yPos < 300){				row = 9;			}else if(yPos < 330){				row = 10;			}else if(yPos < 360){				row = 11;			}									coords.push(col);			coords.push(row);			return coords;		}		public function Grid2Pixel(col, row):Array {			var coords:Array = new Array();			var xPos;			var yPos;						xPos = col * gridSize + gridXOffset + gridHalf;			yPos = row * gridSize + gridYOffset + gridHalf;						coords.push(xPos);			coords.push(yPos);			return coords;		}	}}